#include "system.h"
#include "altera_up_avalon_accelerometer_spi.h"
#include "altera_avalon_timer_regs.h"
#include "altera_avalon_timer.h"
#include "altera_avalon_pio_regs.h"
#include "sys/alt_irq.h"
#include <stdlib.h>
#include <stdio.h>
#include <sys/alt_timestamp.h>

#define OFFSET -32
#define PWM_PERIOD 16
#define F_ORDER 51

alt_8 pwm = 0;
alt_u8 led;
int level;

struct node {
	struct node *next;
	alt_32 val;
}; typedef struct node node;

struct queue{
	node *head;
	node *tail;
	int count;
}; typedef struct queue queue;

void init(queue *q){
	q->head = NULL;
	q->tail = NULL;
	q->count = 0;
}

void enqueue(alt_32 x, queue *q){
	node *tmp = malloc(sizeof(node));
	tmp->val = x;
	tmp->next = NULL;

	if (q->tail == NULL){
		q->head = tmp;
		q->tail = tmp;
	}else{
		q->tail->next = tmp;
		q->tail = tmp;
	}
	q->count++;
}

void dequeue(queue *q){
	node *tmp;
	tmp = q->head;
	q->head = q->head->next;
	free(tmp);
	q->count--;
}


void deallocate(queue *q){
	node *tmp;
	while(q->head != q->tail){
		tmp = q->head;
		q->head = q->head->next;
		free(tmp);
	}

}

alt_32 FIR(float coeffs[], queue *q){
	float tmp = 0;
	node* p;
	p = q->head;
	int i = 0;

	while(p != NULL){
		tmp+=coeffs[i]*(float)(p->val);
		p = p->next;
		i++;
	}

	return (alt_32)tmp;
}

void led_write(alt_u8 led_pattern) {
    IOWR(LED_BASE, 0, led_pattern);
}

void convert_read(alt_32 acc_read, int * level, alt_u8 * led) {
    acc_read += OFFSET;
    alt_u8 val = (acc_read >> 6) & 0x07;
    * led = (8 >> val) | (8 << (8 - val));
    * level = (acc_read >> 1) & 0x1f;
}

void sys_timer_isr() {
    IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_BASE, 0);

    if (pwm < abs(level)) {

        if (level < 0) {
            led_write(led << 1);
        } else {
            led_write(led >> 1);
        }

    } else {
        led_write(led);
    }

    if (pwm > PWM_PERIOD) {
        pwm = 0;
    } else {
        pwm++;
    }

}

void timer_init(void * isr) {

    IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_BASE, 0x0003);
    IOWR_ALTERA_AVALON_TIMER_STATUS(TIMER_BASE, 0);
    IOWR_ALTERA_AVALON_TIMER_PERIODL(TIMER_BASE, 0x0900);
    IOWR_ALTERA_AVALON_TIMER_PERIODH(TIMER_BASE, 0x0000);
    alt_irq_register(TIMER_IRQ, 0, isr);
    IOWR_ALTERA_AVALON_TIMER_CONTROL(TIMER_BASE, 0x0007);

}

int main(){

	float coeffs[]={0.0002, 0.0002, 0.0004, 0.0007, 0.0011, 0.0015, 0.0021, 0.0029, 0.0038, 0.0048, 0.006, 0.0074, 0.0088, 0.0105, 0.0122, 0.0139, 0.0157, 0.0175, 0.0192, 0.0208, 0.0222, 0.0234, 0.0245, 0.0252, 0.0257, 0.0258, 0.0257, 0.0252, 0.0245, 0.0234, 0.0222, 0.0208, 0.0192, 0.0175, 0.0157, 0.0139, 0.0122, 0.0105, 0.0088, 0.0074, 0.006, 0.0048, 0.0038, 0.0029, 0.0021, 0.0015, 0.0011, 0.0007, 0.0004, 0.0002, 0.0002};
	queue *q = malloc(sizeof(queue)) ;
	init(q);
    alt_32 x_read;
    int n = 0;

    alt_up_accelerometer_spi_dev * acc_dev;
    acc_dev = alt_up_accelerometer_spi_open_dev("/dev/accelerometer_spi");

    if (acc_dev == NULL) { // if return 1, check if the spi ip name is "accelerometer_spi"
        return 1;
    }

    for(int i = 0; i < F_ORDER; i++){
    	enqueue(0, q);
    }

    //printf("n, filtered, unfilt");
    timer_init(sys_timer_isr);
    alt_timestamp_start();
    while (1) {
        alt_up_accelerometer_spi_read_x_axis(acc_dev, & x_read);
    	enqueue(x_read, q);
    	dequeue(q);

    	alt_32 y = FIR(coeffs, q);
    	printf("%d, %ld, %ld\n", n, y, x_read);
        // alt_printf("raw data: %x\n", x_read);
        convert_read(y, & level, & led);
    	n++;
    }
    //exec_t2 = alt_timestamp();

    printf("proc time = ticks ,%ld\n", (alt_timestamp()));
    deallocate(q);
    free(q->head);
    free(q);
    return 0;
}
